(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{375:function(t,e,a){"use strict";a.r(e);var r=a(17),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),e("h2",{attrs:{id:"http-缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[t._v("#")]),t._v(" HTTP 缓存")]),t._v(" "),e("h3",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),e("p",[t._v("Response Header 设置 Cache-Control 和 Expires"),e("br"),t._v("\n优先级：Cache-Control > Expires")]),t._v(" "),e("h4",{attrs:{id:"expires-http1-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires-http1-0"}},[t._v("#")]),t._v(" Expires(HTTP1.0)：")]),t._v(" "),e("p",[t._v("缓存的到期时间，若请求时间小于该时间，则直接使用缓存结果。\n使用时间比较缺点：若客户端与服务端的时间由于时区或其他原因不一致，则缓存直接失效")]),t._v(" "),e("h4",{attrs:{id:"cache-control-http1-1-目前浏览器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-http1-1-目前浏览器"}},[t._v("#")]),t._v(" Cache-Control(HTTP1.1,目前浏览器)：")]),t._v(" "),e("ul",[e("li",[t._v("public：所有内容都将被缓存（客户端和代理服务器都可缓存）")]),t._v(" "),e("li",[t._v("private(默认)：所有内容仅客户端可缓存")]),t._v(" "),e("li",[t._v("no-cache：客户端缓存内容，通过协商缓存来决定是否缓存")]),t._v(" "),e("li",[t._v("no-store：不强制缓存，也不协商缓存")]),t._v(" "),e("li",[t._v("max-age=xxx ：缓存内容将在本次请求 xxx 秒后失效，xxx 秒内强制缓存生效")])]),t._v(" "),e("h4",{attrs:{id:"从-network-中的-size-可查看缓存是否生效以及位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从-network-中的-size-可查看缓存是否生效以及位置"}},[t._v("#")]),t._v(" 从 NetWork 中的 size 可查看缓存是否生效以及位置：")]),t._v(" "),e("p",[e("strong",[t._v("from memory cache")]),t._v(" 内存缓存"),e("br"),t._v("\n特点：将编译解析后的文件（如：js 和图片）存在该进程的内存中，方便下次快速读取，进程关闭，内存清空。")]),t._v(" "),e("p",[e("strong",[t._v("from disk cache")]),t._v(" 硬盘缓存"),e("br"),t._v("\n特点：需要对该缓存存放的硬盘文件进行 I/O 操作，然后重新解析内容（如：css），读取复杂，速度比内存缓存慢。")]),t._v(" "),e("blockquote",[e("p",[t._v("浏览器读取缓存的顺序：memory –> disk。")])]),t._v(" "),e("h3",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),e("p",[t._v("当强缓存失效或未设置时，进入协商缓存流程")]),t._v(" "),e("ol",[e("li",[t._v("协商缓存生效，返回 304")]),t._v(" "),e("li",[t._v("协商缓存失效，返回 200 和请求结果")])]),t._v(" "),e("p",[t._v("控制协商缓存的字段分别有："),e("br"),t._v("\nEtag / If-None-Match 和 Last-Modified / If-Modified-Since"),e("br"),t._v("\n优先级：Etag / If-None-Match > Last-Modified / If-Modified-Since")]),t._v(" "),e("h4",{attrs:{id:"last-modified-if-modified-since"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[t._v("#")]),t._v(" Last-Modified / If-Modified-Since")]),t._v(" "),e("p",[t._v("Last-Modified: response header 设置，表示：该资源文件在服务器最后被修改的时间。"),e("br"),t._v("\nIf-Modified-Since：request header 设置，上次请求响应中的 Last-Modified"),e("br"),t._v("\n服务端将两者对比后决定返回 200 或 304")]),t._v(" "),e("h4",{attrs:{id:"etag-if-none-match"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[t._v("#")]),t._v(" Etag / If-None-Match")]),t._v(" "),e("p",[t._v("Etag：资源文件的一个唯一标识(由服务器生成) response header 设置"),e("br"),t._v("\nIf-None-Match：上一个 Etag，request header 设置"),e("br"),t._v("\n服务端将两者对比，一致则返回 304，不一致则返回 200，和新的资源")]),t._v(" "),e("h4",{attrs:{id:"为什么要有-etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有-etag"}},[t._v("#")]),t._v(" 为什么要有 etag？")]),t._v(" "),e("p",[t._v("你可能会觉得使用 last-modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 etag 呢？HTTP1.1 中 etag 的出现（也就是说，etag 是新增的，为了解决之前只有 If-Modified 的缺点）主要是为了解决几个 last-modified 比较难解决的问题：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 get；")])]),t._v(" "),e("li",[e("p",[t._v("某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，if-modified-since 能检查到的粒度是秒级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)；")])]),t._v(" "),e("li",[e("p",[t._v("某些服务器不能精确的得到文件的最后修改时间。")])])]),t._v(" "),e("h2",{attrs:{id:"http-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-协议"}},[t._v("#")]),t._v(" HTTP 协议")]),t._v(" "),e("h3",{attrs:{id:"协议升级机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协议升级机制"}},[t._v("#")]),t._v(" 协议升级机制")]),t._v(" "),e("p",[t._v("由客户端发起，将一个"),e("strong",[t._v("已建立")]),t._v("的"),e("strong",[t._v("http1.1")]),t._v("连接升级成新的、不相容的连接，只能由 http1.1 升级到 http2 或 ws")]),t._v(" "),e("blockquote",[e("p",[t._v("http2 不支持连接升级机制，不支持 101 状态码")])]),t._v(" "),e("h4",{attrs:{id:"配置request-header"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置request-header"}},[t._v("#")]),t._v(" 配置"),e("strong",[t._v("Request Header")]),t._v("：")]),t._v(" "),e("p",[t._v("Connextion：Upgrade"),e("br"),t._v("\nUpgrade: 协议/版本(如：websocket、http/2)"),e("br"),t._v("\n若服务端同意升级本次连接，则返回 101，header 携带 Upgrade：协议"),e("br"),t._v("\nupgrade-insecure-requests：1 表示支持升级机制")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将站点的所有url替换成https的url")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 非跳转(non-navigational)的不安全资源请求会自动升级到HTTPS")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("meta http"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("equiv"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Content-Security-Policy"')]),t._v(" content"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"upgrade-insecure-requests"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),e("h3",{attrs:{id:"tcp-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议"}},[t._v("#")]),t._v(" TCP 协议")]),t._v(" "),e("p",[t._v("为什么是三次握手？"),e("br"),t._v("\n在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。"),e("br"),t._v("\n《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。"),e("br"),t._v("\n通信双方需要就某个问题达成一致。而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上建立可靠传输的最小值。"),e("br"),t._v("\n如果两次就建立，会浪费server的资源。")]),t._v(" "),e("blockquote",[e("p",[t._v("参考："),e("a",{attrs:{href:"https://juejin.cn/post/6844903593275817998",target:"_blank",rel:"noopener noreferrer"}},[t._v("彻底理解浏览器的缓存机制"),e("OutboundLink")],1),e("br"),t._v("\n参考："),e("a",{attrs:{href:"https://www.jianshu.com/p/9c95db596df5",target:"_blank",rel:"noopener noreferrer"}},[t._v("彻底弄懂强缓存与协商缓存"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);